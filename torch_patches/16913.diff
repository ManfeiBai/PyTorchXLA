commit 84256137efc10f794b31575a4465838982cd6426
Author: Davide Libenzi <dlibenzi@google.com>
Date:   Fri Feb 8 20:07:05 2019 -0800

    Allow the variable type associations to depend on backend+scalar_type, like the Type does.

diff --git a/aten/src/ATen/templates/TypeExtension.cpp b/aten/src/ATen/templates/TypeExtension.cpp
index 313b865fc..de7c0175b 100644
--- a/aten/src/ATen/templates/TypeExtension.cpp
+++ b/aten/src/ATen/templates/TypeExtension.cpp
@@ -23,7 +23,7 @@ std::unique_ptr<Generator> ${Type}::generator() const {
 }
 
 ScalarType ${Type}::scalarType() const {
-  AT_ERROR("scalarType is not implemented for ${Type}");
+  return ScalarType::Float;
 }
 
 caffe2::TypeMeta ${Type}::typeMeta() const {
diff --git a/torch/csrc/autograd/VariableTypeManual.cpp b/torch/csrc/autograd/VariableTypeManual.cpp
index 26c2b8b36..1d5fadc87 100644
--- a/torch/csrc/autograd/VariableTypeManual.cpp
+++ b/torch/csrc/autograd/VariableTypeManual.cpp
@@ -63,16 +63,16 @@ TypeID VariableType::ID() const {
   return static_cast<TypeID>(id_);
 }
 
-std::vector<std::unique_ptr<Type>> type_to_variable_type;
+static std::unique_ptr<Type> type_to_variable_type
+    [static_cast<int>(Backend::NumOptions)]
+    [static_cast<int>(ScalarType::NumOptions)];
 
 // XXX - this is not threadsafe with uses of Variables
-void register_variable_type_for(TypeExtendedInterface* baseType) {
+void register_variable_type_for(int backend, int scalar, TypeExtendedInterface* baseType) {
   AT_ASSERT(baseType);
-  const auto base_id = static_cast<size_t>(baseType->ID());
-  if(type_to_variable_type.size() <= base_id) {
-    type_to_variable_type.resize(base_id + 1);
-  }
-  type_to_variable_type[base_id] =
+  AT_ASSERT(backend >= 0 && backend < static_cast<int>(Backend::NumOptions));
+  AT_ASSERT(scalar >= 0 && scalar < static_cast<int>(ScalarType::NumOptions));
+  type_to_variable_type[backend][scalar] =
       make_unique<VariableType>(&at::globalContext(), baseType);
 }
 
@@ -83,7 +83,7 @@ struct VariableTypeRegistry {
       for (int s = 0; s < static_cast<int>(ScalarType::NumOptions); ++s) {
         auto baseType = context.getNonVariableTypeRaw(static_cast<Backend>(p), static_cast<ScalarType>(s));
         if (baseType && baseType->backend() != Backend::Undefined) {
-          register_variable_type_for(baseType);
+          register_variable_type_for(p, s, baseType);
         }
       }
     }
@@ -128,7 +128,9 @@ REGISTER_VARIABLE_HOOKS(VariableHooks)
 // Pre-condition: backend/scalar_type is a valid type in the type_registry
 void VariableHooks::registerVariableTypeFor(at::LegacyTypeDispatch* context, at::Backend backend, at::ScalarType scalar_type) const {
   auto* baseType = context->getNonVariableTypeRaw(backend, scalar_type);
-  register_variable_type_for(static_cast<at::TypeExtendedInterface*>(baseType));
+  register_variable_type_for(static_cast<int>(backend),
+                             static_cast<int>(scalar_type),
+                             static_cast<at::TypeExtendedInterface*>(baseType));
 }
 
 at::Type& VariableHooks::getVariableTypeFromBaseType(const at::Type& baseType) const {
@@ -140,10 +142,9 @@ bool VariableType::isVariableType(const at::Type& type) {
 }
 
 at::TypeExtendedInterface* VariableType::getVariableTypeFromBaseType(const at::Type& baseType) {
-  auto id = static_cast<size_t>(baseType.ID());
-  if(id >= type_to_variable_type.size())
-    return nullptr;
-  return static_cast<at::TypeExtendedInterface*>(type_to_variable_type[id].get());
+  return static_cast<at::TypeExtendedInterface*>(
+      type_to_variable_type[static_cast<int>(baseType.backend())]
+      [static_cast<int>(baseType.scalarType())].get());
 }
 
 namespace {
diff --git a/torch/csrc/autograd/VariableTypeUtils.h b/torch/csrc/autograd/VariableTypeUtils.h
index b37c36d40..6a0051700 100644
--- a/torch/csrc/autograd/VariableTypeUtils.h
+++ b/torch/csrc/autograd/VariableTypeUtils.h
@@ -40,8 +40,6 @@ using namespace torch::autograd::generated;
 
 namespace torch { namespace autograd {
 
-extern std::vector<std::unique_ptr<Type>> type_to_variable_type;
-
 inline void check_inplace(const Tensor& tensor) {
   auto& var = static_cast<const Variable&>(tensor);
   if (var.requires_grad() && var.is_leaf() && GradMode::is_enabled()) {
